
poll源码分析
=====================================

Linux轮询的方法主要为select,poll,epoll,其中select与poll为fd数目较小的情况下使用，而epoll则在fd大量的情况下使用.poll函数接口如下:

    int poll(struct pollfd *fds,nfds_t nfds,int timeout)
	struct pollfd {
	      int fd; /* file descriptor */
		  short events; /* requested events */
		  short revents; /* returned events */
	}
	
poll与select方法非常的相似，都是调用每个fd-->file-->f\_op->poll获取每个文件的事件，然后将每个事件复制到用户端，在数据结构方面采用的是链表poll\_list:

    struct poll_list {
	    struct poll_list *next;
		int len;
		struct pollfd entries[0];
	}

首先将用户参数转换为内部的数据结构:

    int do_sys_poll(struct pollfd __user *ufds,unsigned int nfds,
	        struct timespec *end_time)
	{
	     struct poll_wqueues table;
		 .........
		 for(;;) {
		      //将所有的fd利用链表连接起来,但在分配时却不是一次性的分配所有的fd,而是采用链表方式连接起来
			  //但在使用时就会多采用一次循环,与select相同
		      walk->next = NULL;
			  walk->len = len;
			  if(!len)
			      break;
			   if(copy_from_user(walk->entries,ufds + nfds-todo,\
			              sizeof(struct pollfd) * walk->len))
				   goto out_fds;
				   ...........
			   size = sizeof(struct poll_list) + sizeof(struct pollfd) * len;
			   walk = walk->next = kmalloc(size,GFP_KERNEL);
			   if(!walk) {
			       err = -ENOMEM;
				   goto out_fds;
			   }
		 }
	}


do\_poll则实现了具体的轮询机制,每个fd进行轮询
 
    static int do_poll(unsigned int nfds,struct poll_list *list,
	           struct poll_wqueues *wait,struct timespec *end_time)
	{
	   poll_table* pt = &wait->pt;
	   ktime_t expire,*to = NULL
	   int timed_out = 0,count = 0;
	   unsigned long slack = 0;
	   
	   if(end_time && !end_time->tv_sec && !end_time->tv_nsec) {
	       pt = NULL;
		   timed_out = 1
	   }
	
	   if(end_time && !timed_out)
	       slack = select_estimate_accuracy(end_time);
	   
	   for(;;) { //有事件返回或超时就会退出
	       struct poll_list *walk;
		   //遍历每个fd
		   for(walk = list;walk != NULL;walk = walk->next) {
		      struct pollfd *pfd,*pfd_end;
			  
			  pfd = walk->entries;
			  pfd_end = pfd + walk->len;
			  //
			  for(;pfd != pfd_end;pfd++) {
			      //将返回的事件直接填写至pollfd上面
			      if(do_pollfd(pfd,pt)) {
				     count ++;
					 pt = NULL;
				  }
			  }
		   }
	   pt = NULL;
	   if(!count) {
	      count = wait->error;
		  if(signal_pending(current))
		      count = -EINTR;
	   }
	   if(count || timed_out)
	        break;
	   if(end_time && !to) {
	      expire  = timespec_to_ktime(*end_time);
		  to = &expire;
	   }
	   //设置睡眠等待
	   if(!poll_schedule_timeout(wait,TASK_INTERRUPTIBLE,to,slack))
	       timed_out = 1;
	   }
	   return count;
	}

而do\_pollfd就是调用具体的f_op->poll来判断读写事件情况:

    static inline unsigned int do_pollfd(struct pollfd *pollfd,poll_table *pwait)
	{
	    unsigned int mask;
	    int fd;
	   
	    mask = 0;
		fd = pollfd->fd;
		
		if(fd >= 0) {
		    int fput_needed;
			struct file *file;
			
			file = fget_light(fd,&fput_needed);
			mask = POLLNVAL;
			if(file != NULL) {
			   mask = DEFAULT_POLLMASK;
			   //调用具体文件的poll驱动直接获取可操作的读写事件
			   if(file->f_op && file->f_op->poll) {
			      if(pwait)
				     pwait->key = pollfd->events | POLLERR | POLLHUP;
				  maks = file->f_op->poll(file,pwait);
			   }
			   
			   maks &= pollfd->events | POLLERR | POLLHUP;
			   fput_light(file,fput_needed);
			}
		}
		pollfd->revents = mask;
		
		return mask;
	}

epoll 分析
====================

每当用户调用函数epoll_create,就会创建一个eventpoll对象:

    struct eventpoll {
	    spinlock_t lock;
		struct mutex mtx;
		wait_queue_head_t wq;//epoll_wait
		wait_queue_head_t poll_wait;//用于每个fd中poll轮询的等待队列
		struct list_head rdlist; //ready list,所有fd就绪队列
		struct rb_root rbr;//维护fd的数据结构采用rb-tree方式管理
		struct epitem *ovflist;//连接所有的fd 数据结构
		struct user_struct *user;//创建该epoll的用户信息
	}

轮询部分的源码如下:

    static int ep_poll(struct eventpoll *ep,struct epoll_event __user *events,
				int maxevents,long timeout)
	{
	    int res,eavail,timed_out = 0;
		unsigned long flags;
		long slack;
		wait_queue_t wait;
		ktime_t expires,*to = NULL
		
		.........
		if(list_empty(&ep->rdllist)) {
			init_waitqueue_entry(&wait,current);
			__add_wait_queue_exclusive(&ep->wq,&wait);
			
			for(;;) {
				set_current_state(TASK_INTERRUPTIBLE);
				if(!list_empty(&ep->rdllist) || timed_out) 
					break;
				......
				if(!schedule_hrtimeout_range(to,slack,HRTIMER_MODE_ABS))
				    timed_out = 1;
				....
			}
			__remove_wait_queue(&ep->wq,&wait);
			set_current_state(TASK_RUNNING);
		}
		eavali = !list_empty(&ep->rdllist) || ep->ovflist != EP_UNACTIVE_PTR;
		.......
		if(!res && eavail &&
		   !(res = ep_send_events(ep,events,maxevents)) && !timed_out)
		   goto retry;
		   
		return res;
	}
	
	ep_send_events
	            --------> ep_scan_ready_list
				        ---->ep_send_events_proc
	
	static int ep_scan_ready_list(struct eventpoll *ep,int (*sproc)(strut eventpoll *,
						struct list_head *,void *),
						void *priv)
	{
	    int error,pwake = 0;
		unsigend long flags;
		struct epitem *epi,*nepi;
		
		LIST_HEAD(txlist);
	
	    mutex_lock(&ep->mtx);
		spin_lock_irqsave(&ep->lock,flags);
		list_splice_init(&ep->rdllist,&txlist);
		ep->ovflist = NULL;
		spin_unlink_irqrestore(&ep->lock,flags);
		
		error = (*sproc)(ep,&txlist,priv);
		spin_lock_ireqsave(&ep->lock,flags);
		
		for(nepi = ep->ovflist,(epi = nepi) != NULL;
		    nepi = epi->next,epi->next = EP_UNACTIVE_PTR) {
			
			if(!ep_is_linked(&epi->rdllink));
			   list_add_tail(&epi->rdllink,&ep->rdlist);
		}
		
		ep->ovflist = EP_UNACTIVE_PTR;
		list_splice(&txlist,&ep->rdllist);
		
		if(!list_empty(&ep->rdllist)) {
		      if(waitqueue_active(&ep->wq))
			     wake_up_locked(&ep->wq);
		      if(waitqueue_active(&ep->poll_wait))
			     pwake++;
		}
		spin_unlock_ireqrestore(&ep->lock,flags);
		mutex_unlock(&ep->mtx);
		
		if(pwake)
		    ep_poll_safewake(&ep->poll_wait);
			
		return error;
	}
	
	static int ep_send_events_proc(struct eventpoll *ep,struct list_head *head,
						void *priv)
	{
	 		struct ep_send_events_data *esed = priv;
			int eventcnt;
			unsigned int revents;
			struct epitem *epi;
			struct epoll_event __user *uevent;
			
			for(eventcnt = 0,uevent = esed->events;
				!list_empty(head) && eventcnt < esed->maxevents;) {
				
				epi = list_first_entry(head,struct epitem,rdllink);
				list_del_init(&epi->rdllink);
				revents = epi->ffd.file->f_op_poll(epi->ffd.file,NULL) &
				   epi->event.events;
				
				if(revents) {
				    if(__put_user(revents,&uevent->events) ||
					   __put_user(epi->event.data,&uevent->data)) {
					   list_add(&epi->rdllink,head);
					   return eventcnt ? eventcnt:-EFAULT;
					}
					eventcnt ++;
					uevent ++;
					if(epi->event.events & EPOLLONESHOT)
					  epi->event.events &= EP_PRIVATE_BITS;
					else if(!(epi->event.events & EPOLLET)) {
					   list_add_tail(&epi->rdllink,&ep->rdllist);
					}
				}
			}
			
			return eventcnt;
	}

当新来的fd加入到epoll监听时，epoll就会对该fd进行poll驱动监听.
    
	static int ep_insert(struct eventpoll *ep,struct epoll_event *event,
				   struct file *tfile,int fd)
	{
	    int error,revents,pwake = 0;
		unsigned long flags;
		struct epitem *epi;
		struct ep_pqueue epq;
		
		user_watches = atomic_long_read(&ep->user->epoll_watches);
		if(unlikely(user_watches >= max_user_watches))
		   return -ENOSPC;
		if(!(epi = kmem_cache_alloc(epi_cache,GFP_KERNEL)))
		   return -ENOMEM;
		
		INIT_LIST_HEAD(&epi->rdllink);
		INIT_LIST_HEAD(&epi->fllink);
		INIT_LIST_HEAD(&epi->pwqlist);
		epi->ep = ep;
		ep_set_ffd(&epi->ffd,tfile,fd);
		....
		epi->next = EP_UNACTIVE_PTR;
		epq.epi = epi;
		init_poll_funcptr(&epq,pt,ep_ptable_queue_proc);
		
		revents = tfile->f_op->poll(tfile,&epq.pt);
		
		error = -ENOMEM;
		if(epi->nwait < 0) 
		   goto error_unregister;
		
		spin_lock(&tfile->f_lock);
		
	}
